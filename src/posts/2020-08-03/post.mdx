---
title: Property based testing with Fast-check
slug: property-based-testing-fast-check
image: ./images/select-color.jpg
date: 2020-08-03
category: Test
readTime: 10
tags: ['test', 'property-based-testing', 'javascript', 'typescript']
---

<blockquote >
I didn't write any blog for the entire July. But I wasn't just relaxing and enjoying summer vacation :D
In fact, this July I have learnt so many more things than usual, while creating a vscode extension. <br />
In the effort of creating this extension, I incorporated functional programming, redux, redux-saga for side effects, and property based testing.  <br />
This blog is focused on property based testing. But later, maybe next week, I have a new blog about using redux and redux-saga with vscode tree view API, which I am so excited about.
</blockquote>

### What is property based testing

If you are used to write **test cases** (like I was), then the biggest difference of property based testing, is that it is **generative**.
You do not provide specific test case as input. Instead, you use a library/framework, that generates a bunch of data for you to feed into your function.
<br />

### A simpe example

Let's say we have this function:
```ts
/**
 * Print the word 'Fizz' if num is divisible by 3
 * Print the word 'Buzz' if num is divisible by 5
 * Subsequently print 'FizzBuzz' if num is divisible by 3 and 5
 * Otherwise, just print out num
 */
const simpleFizzBuzz = (num: number) => {
  let output = '';
  if (!(num % 3)) output += 'Fizz';
  if (!(num % 5)) output += 'Buzz';
  if (output.length) return output;
  return num;
};
```

Now to imaging writing some test cases for this function, what would they be?
1. We would of course like to test if `simpleFizzBuzz` work with 'special' input: <br/>
`num = 3` or `num = 5` or `num = 3*5`
2. We would probably also like to test when num is negative: <br/>
`num = -3` or `num = -5` or `num = -3*5`
3. Then there're 'edgy' cases to handle: <br/>
nums is a float, or num = 0, or num is not decimal, or num is not a real number at all

<br />

To write specific test cases addressing all above, is time consuming, and not fun.
But with property based testing, we shift focus, from trying to come up with **examples** of possible input, to **generate** many possible inputs. And we test if the outputs fits the property of our function, meaning, what we expect to see.

In our case, the **property of our function** lies in its description:
- when inputs are `not divided by 3`, and `not divided by 5`, our function give output as the input;
- when inputs are `divided by 3`, and `not divided by 5`, our function give output `Fizz`;
- when inputs are `not divided by 3`, and `divided by 5`, our function give output `Buzz`;
- when inputs are `divided by 3`, and `divided by 5`, our function give output `FizzBuzz`;

<br />

I used [fast-check](https://github.com/dubzzz/fast-check) library to describe all the properties above:

```ts
import fc from 'fast-check';
import simpleFizzBuzz from './simpleFizzBuzz';

describe('properties test with integer and float input', () => {
  const notDividedBy3 = (num: number) => !!(num % 3);
  const notDividedBy5 = (num: number) => !!(num % 5);

  // Test the first property:
  it('should return input when "notDividedBy3" and "notDividedBy5" ', () => {
    fc.assert(
      // fc.property:
      // the first arg is a set of inputs generated by fast-check, according to our description
      // the second arg is the predication we made for the property being tested
      fc.property(
        // We specify here we would like input to our function to be either integer or float.
        // Then fast-check generates a set of inputs like so
        fc.oneof(fc.integer(), fc.float()),
        (input) =>
          notDividedBy3(input) && notDividedBy5(input)
            ? simpleFizzBuzz(input) === input // we test if output matches the property
            : true // we don't care about input in other cases
      )
    );
  });

  // Now we could write similar tests for the other 3 properties
  it('should return "Fizz" when "dividedBy3" and "notDividedBy5" ', () => {
    fc.assert(
      fc.property(fc.oneof(fc.integer(), fc.float()), (input) =>
        !notDividedBy3(input) && notDividedBy5(input)
          ? simpleFizzBuzz(input) === 'Fizz'
          : true
      )
    );
  });
  it('should return "Buzz" when "notDividedBy3" and "dividedBy5" ', () => {
    fc.assert(
      fc.property(fc.oneof(fc.integer(), fc.float()), (input) =>
        notDividedBy3(input) && !notDividedBy5(input)
          ? simpleFizzBuzz(input) === 'Buzz'
          : true
      )
    );
  });
  it('should return "FizzBuzz" when "dividedBy3" and "dividedBy5" ', () => {
    fc.assert(
      fc.property(fc.oneof(fc.integer(), fc.float()), (input) =>
        !notDividedBy3(input) && !notDividedBy5(input)
          ? simpleFizzBuzz(input) === 'FizzBuzz'
          : true
      )
    );
  });
});

```

As we could see, with just 4 test set, we are able to feed our `simpleFizzBuzz` with many inputs. This is where I like property based testing the most:

<blockquote display='info'>
Test as many cases as possible, with the least possible amount of code
</blockquote>

### Use filter with fast-check arbitrary

As you can see, we only test 1 property per test, but we always generate some inputs that does not apply to the property being tested. This is why we have this weird `: true` in the code above.

Luckily, Fast-Check provides a nice function to `filter` the arbitrary. So we could improve our test to be more readable:
```ts
it('should return input when "notDividedBy3" and "notDividedBy5" ', () => {
  fc.assert(
    fc.property(
      fc
        // We still specify here we would like input to be either integer or float.
        .oneof(fc.integer(), fc.float())
        // And now we use filter to customize the generated inputs
        .filter((input) => notDividedBy3(input) && notDividedBy5(input)),
      (input) => simpleFizzBuzz(input) === input // this way the prediction is more readable
    )
  );
});
```
<blockquote display='info'>
Customizable test data is not the only reason I like Fast-Check. <br />
There're similar libraries, for example JSVerify (which actually has more stars on github). <br />
I like Fast-Check more also because it is newer and it has really great in-package support for typescript. And personally I think it is more readable than JSVerify.
</blockquote>

### At the end:
#### Some things to keep in mind while doing property based testing

For me, the hardest part of property based testing, is to find the correct properties to test.
On this term, I found a talk by Matt Bachmann on Pycon 2016 (a bit old I know but he gave a really great talk).

<iframe width="896" height="504" src="https://www.youtube.com/embed/jvwfDdgg93E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Here's the [deck](https://speakerdeck.com/pycon2016/matt-bachmann-better-testing-with-less-code-property-based-testing-with-python?slide=2)

After watching his talk, here're the things I always ask myself, before starting to write properties based tests:
1. How can I use test to make my code explode? <br />
It helps to pretend the code is written by someone that annoys you :D
2. Is there anything reversible there? <br/>
My most recent encounter of this: <br />
I was using vscode API. Vscode keeps some files by virtual document manager, for example the git deleted files. How vscode knows where to look for those 'virtual files', is by virtual uri. Each virtual file has a virtual uri. <br />
I needed to create my own virtual document manager, and therefore I need to write my own `fromVirtualDocUri` and `toVirtualDocUri` method. When thinking in the property based testing way, I would want to test `toVirtualDocUri(fromVirtualDocUri(uri)) === uri`
3. Is there any brute force way to implement the function that I am testing? <br />
I like fast and fancy algorithms, and I think most of the developers I know also do :D But sometimes, the 'fancy' algorithms we come up with, is not necessarily correct. Brute force algorithms, on the other hand, is easier to code and could be more reliable. So they could be a golden standard for our 'fancy' function. <br />
This way of thinking also applies in **refactoring**.
4. Does difference sequence of input changes the output of my function? (stateful testing) <br />
When coding in functional programming style, it is good to have many pure functions. But sometimes, we have to deal with side effects, or the edge of the product. And when we do, stateful testing could help us to 'purify' our functions, and reduce possible run time errors. <br />
Matt gave a really great example in the presentation: max-heap.
We could test a heap 'push' first, followed by a 'pop', does not change the properties of our heap. We could also test a 'pop' first, followed by a 'push' would not mess things up either.
